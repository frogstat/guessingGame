Siktar på VG

Vad är pull respektive push?
	
	pull är när du uppdaterar din local repository med det som finns i remote repository.
	t.ex om du ligger bakom och måste uppdatera dina filer till det senaste versionen från github.

	push är när du uppdaterar remote med din lokala repo.
	T.ex när du har gjort nya commits och vill skicka dem till din github repo.

När använder man log respektive status?
	
	log används för att se commit historik för repot.
	Där kan du se både var du är i historiken, samt var remote repository är.
	
	status används för att se information om din repo.
	Den visar ändringar, vad som finns i staging area, vilken branch du är på osv.
	Den visar även om du är före eller efter remote repository.

Vad är en git branch och varför är de viktiga?
	
	En branch är ett sätt att ha flera grenar av din repo.
	Det låter dig göra ändringar utan att påverka din main branch.
	Väldigt bra när du vill testa nya saker, funktioner osv. utan att riskera att något förstörs.
	Du kan också slå ihop dina grenar när du är klar.

Det finns flera sätt att rulla tillbaka koden till ett tidigare tillstånd.
Förklara skillnaden och motivera när man skulle använda den ena eller andra metoden.

	restore: Återställer filer från en viss commit. Har ingen påverkan på din commit historik.	
	revert: Skapa en ny commit som tar bort ändringarna du gjorde.
	reset: flyttar HEAD till en viss commit i din historik. finns flera varianter.
	reset --hard : flyttar HEAD till en viss commit och återställer din staging area och katalog.
	reset --mixed: flyttar HEAD och återställer staging area, men inte din katalog.
	reset --soft: flyttar HEAD, men återställer inte din staging area eller katalog.

	Användning:
		För de olika typerna av reset:
			Om man har gjort ett litet fel i sina ändringar och commitat det,
			så kan man köra reset --mixed för att enkelt fixa och göra en ny commit.
			Detta är även bra om du har commitat två saker samtidigt när de borde vara enskilda.

			Har man bara nämnt sin commit fel, kan man använda reset --soft och bara commita igen, eller använda commit --amend.

			Har man gjort jättefel och vill bara bli av med allt efter en viss commit, kan man använda reset --hard istället.
			
			Reset är väldigt riskabelt vid grupparbete eftersom den påverkar commit historik.
			Vill man ha ett säkrare sätt att ta bort ändringar kan man använda revert istället.
			
			Restore kan användas både till att återställa filer och att tömma staging area med git restore --staged
			Har du tagit bort dina filer, kan du få tillbaka dem med git restore.
			Vill du ha en äldre version av en fil, kan du använda git restore --source=HEAD~ eller ange hash kod till en commit.


	exempel: git reset --hard HEAD~1
		 HEAD is now at d11e99f Change guessing range from 1000 to 10 for main
		
		 git revert HEAD
		 [testarea 8bbbb29] Revert "Change guessing range from 1000 to 10 for main"
		 1 file changed, 2 insertions(+), 2 deletions(-)	

		 git restore GuessingGame.java
		 (ingen output)

		 git restore --staged GuessingGame.java
		 (ingen output)


Beskriv och jämför hur man kan använda git rebase och git merge i ett scenario
där flera utvecklare jobbar på olika feature branches. Diskutera fördelarna och
nackdelarna med båda teknikerna, samt hur de påverkar historiken.

	git merge: skapa en ny commit som slår ihop ändringarna i två olika grenar. Historiken är oförändrad.

	feature:     A -> B                         A ->  B
	            /               blir till:     /       \
	main:      C -> D -> E                    C -> D -> E

	git rebase: slå ihop genom att sätta dina commits i feature ovanpå din senaste version av main.

	feature:         A - > B
	                /             blir till: C -> D -> E -> A -> B
	main:    C - > D -> E

Uppgift: Skapa ett repo med två eller fler feature branches som utvecklare arbetar på.
Beskriv hur du löser konflikter som uppstår under rebase och merge och visa slutresultatet i historiken.

	output merge:
		från main:
		git merge feature1 -> konflikt, hantera konflikter i textredigerare, git add ., git merge --continue
		sedan samma sak med feature2
		slutlogg:
			a3d2456 (HEAD -> main) Merge branch 'feature2'
			6ad1121 Merge branch 'feature1'
			5bf58fd Update main after creating branches
			ed816e1 (feature2) add second feature
			e0897d8 (feature1) add first feature
			214fb1e add main

	output rebase:
		från feature1:
		git rebase main, hantera eventuella konflikter som tidigare, sedan merge från main vilket leder till fast-forward (ingen merge commit)
		Sedan samma sak från feature2
		slutlogg:
			2a209eb (HEAD -> main, feature2) add second feature
			cde5053 (feature1) add first feature
			6ffcd63 Update main after creating branches
			214fb1e add main


	Som vi kan se är loggen med rebase mycket enklare att läsa.
	Den stora nackdelen är att vi har nu ändrat historiken, vilket kan skapa konflikt för andra utvecklare.
	Troligtvis kommer en vanlig git push inte fungera efter en rebase, så du måste göra git push --force eller den säkrare git push --force-with-lease
	Merge har fördelen att den visar precis vilken ordning som ändringarna har gjorts. Alltså att den bibehåller kontext.
	Merge skapar också mindre konflikt, men den leder ofta till mer svårlästa loggar om du har många merge.


	Exempel på konflikt:
	<<<<<<< HEAD
	first feature
	=======
	second feature
	>>>>>>> ed816e1 (add second feature)

	En manuell hantering av detta kan se ut som:

	first feature
	second feature
